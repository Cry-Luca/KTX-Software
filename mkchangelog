#! /bin/bash

# Generate release notes from git log.
#
# mkrelnotes [-b] [-d] [-p <preface> <this release> <last release>
#
# <preface> is inserted between the title and the detailed change list
# that is extracted with git log. It should be used to summarize
# new features and known issues using level 3 (###) headings for those
# sections.
#
# If -b is specified build system changes will be included in the
# release # notes.
#
# If -d is specified any previous relnotes.md file will be deleted, otherwise
# any such file will be appended, with the title lines stripped, to the release
# notes generated here, thus enabling cumulative release notes.

# Depth of this script relative to the project root
depth=.

# The author name in a commit message comes from whatever the user
# has set as user.name in their git config. It usually has no relation
# to their GitHub username so putting an @ before it has no meaning.
#
# Even if PR's the commit has the full name of the user as known to GitHub,
# not their GitHub username.
SUMMARY_FORMAT_W_AUTH="* %s (%h) (%an)"
SUMMARY_FORMAT="* %s (%h)"

function commit_summary() {
  local hash=$1
  local summary
  local prjson
  pr=$(git log --oneline -n 1 $hash | grep -o -E "\(#[0-9]+\)" | grep -o -E "[0-9]+")
  if [ -z "$pr" ]; then
    # We only use the author name from the commit when we have no other choice.
    summary=$(git log --pretty="$SUMMARY_FORMAT_W_AUTH" -n 1 $hash)
  else
    # It's a PR. Get the GitHub username of the author via the GitHub API
    # so there is a link back to the person.
    summary=$(git log --pretty="$SUMMARY_FORMAT" -n 1 $hash)
    prjson="$(curl -n https://api.github.com/repos/KhronosGroup/KTX-Software/pulls/$pr 2>/dev/null)"
    author="$(echo $prjson | jq -r -e ".user.login")"
    summary+=" (@$author)"
  fi
  echo "$summary"
  if [ -n "$includeDetails" ]; then
    body="$(git log --pretty="%b" -n 1 $hash | sed -E 's/^(.+)/  \1/')"
    if [ -n "$body" ]; then
      echo ""
      # Remove CR which some multi-line commit bodies contain for unknown reasons.
      echo "$body" | tr -d \\r
    fi
  fi
}

function revisions_in () {
  local range=$1; shift
  git rev-list $range $*
}

function log() {
  local part=$1; shift
  local log
  for rev in $(revisions_in "${lastrel}.." $*); do
    # For reasons I do not understand I have been completely unable to prevent
    # trailing newlines from being removed from the output of commit_summary
    # so resorting to ANSI-C quoting to insert some new lines between summaries.
    log+="$(commit_summary $rev)"
    log+=$'\n\n'
  done
  if [ -n "$log" ]; then
    echo "### $part"
    echo
    echo "$log"
    echo
  fi
}

while true; do
  case $1 in
    -b) includeBuildSystem="true"; shift ;;
    -c) cumulative="true"; shift;;
    -d) includeDetails="true"; shift ;;
    -p) preface=$2; shift 2 ;;
    -t) includeTests="true"; shift ;;
    *) break ;;
  esac
done

if [ $# -ne 2 ]; then
  echo "$0: Need this release and last release identifiers."
  exit 1
else
# thisrel=$1
thisrel=v4.0.0-beta4
# lastrel=$2
lastrel=v4.0.0-beta3
fi

RELNOTES_FILE="CHANGELOG.md"
SAVED_RELNOTES_FILE="${RELNOTES_FILE%.md}-$lastrel.md"

# Save or remove old relnotes.
if [ -f $RELNOTES_FILE ]; then
  if [ -z "$cumulative" ]; then
    rm $RELNOTES_FILE;
  else
    mv $RELNOTES_FILE $SAVED_RELNOTES_FILE
  fi
fi

# Read preface file before cd.
if [ -n "$preface" ]; then
  PREFACE=$(cat $preface)
fi

# Change dir to the pkgdoc folder, a child of the script location...
cd $(dirname $0)

exec > $RELNOTES_FILE

# Change to project root.
pushd $depth > /dev/null

lib=$(log libktx lib)
tools=$(log Tools tools)
tests=$(log "Tests" tests)
js_binding=$(log "JS Wrappers" interface/js_binding)

if [ -n "$includeBuildSystem" ]; then
   cmake=$(log "Build System" $(find . \( -path ./build -o -path ./.git -o -path ./other_include \) -prune -false -o -name CMakeLists.txt -o -name '*.cmake'))
fi


cat <<- EOF
Release Notes
=============
## Version ${thisrel#v}
$PREFACE
### Changes since $lastrel (by part)
$lib
$tools
$tests
$js_binding
$cmake
EOF


popd > /dev/null

if [ -f $SAVED_RELNOTES_FILE ]; then
  awk '! /Release Notes/ && ! /======/ {print}' $SAVED_RELNOTES_FILE
  rm $SAVED_RELNOTES_FILE
fi
